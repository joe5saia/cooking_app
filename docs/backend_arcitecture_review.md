# RFC: Backend Architecture Review (Go)

Status: Draft  
Last updated: 2025-12-17  
Scope: `backend/` (Go API + CLI)

## Summary

The backend is a small, pragmatic Go service built around:

- `cmd/api`: an HTTP API server with graceful shutdown.
- `internal/httpapi`: a chi router and handlers that implement the REST API.
- `internal/db/sqlc` + `backend/internal/db/query/*`: typed DB access generated by sqlc on top of Postgres.
- `backend/migrations` + `internal/migrations`: schema migrations managed with goose.
- `internal/auth/*`: password hashing and Personal Access Token (PAT) helpers.
- Integration tests that exercise HTTP + Postgres via `testcontainers-go`.

Overall, the codebase is aligned with common Go MVP patterns (explicit wiring in `cmd/`, limited interface abstraction, `context` at I/O boundaries, and typed DB access via sqlc). This RFC focuses on the highest-leverage risks as complexity grows:

1) “handler-as-service” change amplification in `internal/httpapi`,  
2) inconsistent error/validation response shapes,  
3) OpenAPI contract drift (notably around auth semantics and error shapes),  
4) schema drift risk (goose migrations vs sqlc schema inputs),  
5) security gaps typical in MVPs (authorization model, CSRF, rate limiting, token lifecycle).

## Goals / Non-goals

Goals:

- Evaluate current backend structure against idiomatic Go and general design principles (separation of concerns, coupling/cohesion, testability, maintainability).
- Identify concrete pros/cons and the likely failure modes as the codebase grows.
- Recommend remediations that preserve Go’s preference for simplicity.

Non-goals:

- Propose a full “hexagonal/clean architecture” rewrite.
- Evaluate frontend, infra, or product requirements beyond what impacts backend architecture.

## Assumptions and verification anchors

This RFC references “as implemented” behavior. Each concrete claim SHOULD be backed by at least one of:

- a file + function/type name reference,
- a test name that asserts the behavior,
- or a short code excerpt.

Examples of current anchors in this repo:

- Router/auth wiring: `backend/internal/httpapi/routes.go` (`routes`) and `backend/internal/httpapi/middleware_auth.go` (`authMiddleware`, `authenticateRequest`).
- Session cookie auth implementation: `backend/internal/httpapi/auth.go` (`handleLogin`, `handleLogout`, `handleMe`).
- OpenAPI validation (paths-only): `backend/internal/openapi/openapi_test.go` (`TestOpenAPI_IsValidAndHasRequiredPaths`).
- Logging behavior: `backend/internal/httpapi/middleware_requestlog.go` (`requestLogger`) and `backend/internal/httpapi/requestlog_test.go`.
- sqlc schema source vs runtime migrations: `backend/sqlc.yaml` and `backend/internal/testutil/pgtest/pgtest.go` (`MigrateUp`).

## Current architecture (as implemented)

### Entry points

- API server: `backend/cmd/api/main.go`
  - Loads config from environment via `backend/internal/config`.
  - Creates a JSON logger via `backend/internal/logging` (`slog`).
  - Constructs the API app via `httpapi.New`.
  - Runs `http.Server` with graceful shutdown.

- CLI/other: `backend/cmd/cli/main.go`
  - Includes `bootstrap-user` subcommand that creates the first user via `bootstrap.CreateFirstUser`.
  - Currently provides only admin/ops subcommands (no demo runner).

Evidence:

- API graceful shutdown + server timeouts: `backend/cmd/api/main.go` (`run`).
- Config loading: `backend/internal/config/config.go` (`FromEnv`).
- App wiring + DB ping: `backend/internal/httpapi/app.go` (`New`).
- Bootstrap user flow: `backend/cmd/cli/main.go` (`bootstrap-user`) and `backend/internal/bootstrap/bootstrap.go` (`CreateFirstUser`).

### HTTP layer

`backend/internal/httpapi` contains:

- An `App` struct (`backend/internal/httpapi/app.go`) holding shared dependencies:
  - `*slog.Logger`
  - `*pgxpool.Pool` and `*sqlc.Queries`
  - Session cookie settings (name/ttl/secure)
- Router construction in `backend/internal/httpapi/routes.go` using `chi` with standard middleware.
- Handlers grouped by resource/file (`users.go`, `tags.go`, `recipe_books.go`, `recipes*.go`, `auth.go`, `tokens.go`).
- Custom middleware:
  - Request logging (`middleware_requestlog.go`)
  - Auth (`middleware_auth.go`) supporting cookie sessions and bearer PATs
- A shared response helper package: `backend/internal/httpapi/response`

The handler implementation is generally “thin controller + direct sqlc calls”: handlers decode/validate requests, perform DB operations (sometimes with explicit transactions), and encode response JSON.

Evidence:

- Router + middleware stack + endpoints: `backend/internal/httpapi/routes.go` (`routes`).
- Request logging fields: `backend/internal/httpapi/middleware_requestlog.go` (`requestLogger`) with tests in `backend/internal/httpapi/requestlog_test.go`.
- Auth flow and precedence (bearer first, then cookie): `backend/internal/httpapi/middleware_auth.go` (`authenticateRequest`).
- Session cookie behavior: `backend/internal/httpapi/auth.go` (`handleLogin`, `handleLogout`, `handleMe`).

### Persistence layer

- `backend/internal/db/sqlc`: generated query methods and models.
- SQL lives in `backend/internal/db/query/*` and `backend/internal/db/schema.sql` (sqlc config in `backend/sqlc.yaml`).
- Migrations run via goose; tests rely on `internal/migrations.Dir()` to locate migration files.

Evidence:

- sqlc schema input: `backend/sqlc.yaml`.
- Schema file used by sqlc: `backend/internal/db/schema.sql`.
- Migration directory resolver: `backend/internal/migrations/migrations.go` (`Dir`).
- Migrations applied in tests: `backend/internal/testutil/pgtest/pgtest.go` (`MigrateUp`).

### Testing strategy

- Integration tests are prominent (HTTP tests, sqlc integration tests, migration tests).
- Postgres is started via `testcontainers-go` in `backend/internal/testutil/pgtest`.
- OpenAPI spec validity and required paths are tested in `backend/internal/openapi/openapi_test.go` (note: this currently validates presence of paths, not full request/response contract correctness).
- Tests that require Docker will skip locally when Docker is unavailable, unless `CI` is set (to fail fast).

Evidence:

- OpenAPI test scope: `backend/internal/openapi/openapi_test.go` (`TestOpenAPI_IsValidAndHasRequiredPaths`).
- Docker-dependent test behavior: `backend/internal/testutil/pgtest/pgtest.go` (`Start`).
- Test suite size snapshot (2025-12-17): 25 `*_test.go` files under `backend/internal/`, including 15 under `backend/internal/httpapi/`.

## What’s working well (Pros)

### Idiomatic Go structure and dependency hygiene

- `internal/` boundaries are used well to prevent accidental external coupling.
- Explicit dependency wiring in `cmd/api` is easy to reason about.
- `context.Context` is consistently threaded through I/O boundaries.
- `slog` usage is straightforward; JSONL output and stable `ts` key are test-friendly.

Evidence:

- `internal/` package boundary usage: `backend/internal/*` (Go enforces internal import rules).
- Explicit wiring: `backend/cmd/api/main.go` (`config.FromEnv` -> `logging.New` -> `httpapi.New`).
- `context` propagated to DB and handlers: `backend/internal/httpapi/*` uses `r.Context()` for sqlc calls; `backend/internal/httpapi/app.go` uses `ctx` for pool init and ping.
- `slog` JSONL formatting: `backend/internal/logging/logging.go` (`New` with `slog.NewJSONHandler` and `ReplaceAttr` for `ts`), tested via `backend/internal/httpapi/requestlog_test.go`.

### Pragmatic layering (right-sized for MVP)

- Minimal abstraction at the HTTP boundary: most handlers call sqlc queries directly (with a small repository wrapper in a few places), which keeps call graphs short and explicit.
- sqlc provides typed DB access while keeping SQL explicit (queries live in `backend/internal/db/query/*`).

Evidence:

- Direct sqlc usage in handlers: e.g., `backend/internal/httpapi/tags.go` (`a.queries.*`), `backend/internal/httpapi/recipes_list.go` (`a.queries.ListRecipes`).
- A small repo wrapper exists (not a broad service layer): `backend/internal/auth/users/users.go` (`Repo`).

### Operational and correctness basics are in place

- Graceful shutdown with `http.Server.Shutdown` and timeouts.
- Router middleware includes request IDs, RealIP, recoverer, and request timeouts.
- Auth primitives include some necessary security controls:
  - Password hashing via `x/crypto`.
  - PAT secrets are generated randomly and only the hash is stored.
  - Session cookies are `HttpOnly`, `SameSite=Lax`, with configurable `Secure`.
  - Auth precedence is well-defined in middleware: bearer PAT is checked before cookie session (`backend/internal/httpapi/middleware_auth.go`).
  - Session lifetime and cookie security mode are configurable via env (`SESSION_TTL_HOURS`, `SESSION_COOKIE_SECURE`).

Open questions that affect security posture:

- What is the CSRF strategy for cookie-authenticated unsafe methods?
- Are login and token issuance endpoints rate-limited?
- Is there an explicit authorization model (ownership/admin/scopes), or are all authenticated users “equally trusted”?
- Is `SESSION_COOKIE_SECURE` set appropriately per environment (it defaults to `false` in `backend/internal/config/config.go`)?

Evidence:

- Graceful shutdown: `backend/cmd/api/main.go` (`server.Shutdown`) and chi timeout middleware in `backend/internal/httpapi/routes.go` (`middleware.Timeout`).
- Router middleware stack: `backend/internal/httpapi/routes.go` (`middleware.RequestID`, `middleware.RealIP`, `middleware.Recoverer`, `middleware.Timeout`).
- Cookie flags: `backend/internal/httpapi/auth.go` (`http.SetCookie` in `handleLogin`/`handleLogout`).
- Password hashing is Argon2id: `backend/internal/auth/password/password.go` (`Hash`, `Verify`, `DefaultParams`).
- PAT generation and storage: `backend/internal/auth/pat/pat.go` (`Generate`) and `backend/internal/httpapi/tokens.go` (`handleTokensCreate`).
- Session config: `backend/internal/config/config.go` (`SESSION_TTL_HOURS`, `SESSION_COOKIE_SECURE`).

### Broad integration test coverage for an early-stage app

- The integration-test approach catches “real” issues across handlers, SQL, and migrations (for example `backend/internal/httpapi/*_test.go` suites that boot Postgres + an HTTP server).
- Migration tests validate important schema invariants (constraints, indexes, citext usage).
- OpenAPI validation test helps keep spec drift visible.

Evidence (examples, not exhaustive):

- Auth/session integration coverage: `backend/internal/httpapi/auth_test.go`.
- Recipe workflows integration coverage: `backend/internal/httpapi/recipes_create_test.go`, `backend/internal/httpapi/recipes_update_test.go`, `backend/internal/httpapi/recipes_delete_restore_test.go`.
- Logging behavior coverage: `backend/internal/httpapi/requestlog_test.go`.
- Migration invariants coverage: `backend/internal/migrations/schema_test.go`.

## Where the design may become costly (Cons / Risks)

### 1) HTTP handlers are accumulating “use-case” logic

Several endpoints (notably recipe create/update) contain multi-step business workflows:

- Validation + normalization
- Referential integrity checks
- Transactions + multi-table writes
- Response projections and post-write fetches

This is common in MVPs, but the risk is that the `httpapi` package becomes the de-facto domain layer. As complexity grows (permissions, more invariants, asynchronous work, etc.) the handlers can become harder to test and evolve without subtle regressions.

Design principle impact:

- Single Responsibility: handlers are both “transport” and “application logic”.
- Open/Closed: changes to business rules frequently require editing handler code across multiple endpoints.

Evidence:

- Multi-step transactional workflows in handlers: `backend/internal/httpapi/recipes.go` (`handleRecipesCreate`) and `backend/internal/httpapi/recipes_update.go` (`handleRecipesUpdate`).

### 2) Inconsistent response and validation shapes

There are multiple patterns for validation and error details:

- `response.FieldError` and `response.WriteProblem`
- `App.writeValidation` which returns `[]map[string]string`
- Some handlers return a single “invalid id” problem, others return “validation failed” with field lists

This creates avoidable churn for clients and increases cognitive load for maintainers.

Design principle impact:

- DRY: repeated ad-hoc shapes lead to duplicated parsing/serialization logic.
- Consistency contract: makes OpenAPI harder to keep accurate.

Evidence:

- Validation errors as `[]response.FieldError`: `backend/internal/httpapi/recipes_validation.go` (`validateCreateRecipeRequest`) and `backend/internal/httpapi/response/response.go` (`FieldError`, `WriteProblem`).
- Validation errors as `[]map[string]string`: `backend/internal/httpapi/session.go` (`writeValidation`).

### 3) Auth endpoints do not fully match OpenAPI security semantics

The OpenAPI spec declares `cookieAuth` and `bearerAuth` for:

- `GET /api/v1/auth/me`
- `POST /api/v1/auth/logout`

But current implementation behavior in `backend/internal/httpapi/routes.go` + `backend/internal/httpapi/auth.go` is:

- `GET /api/v1/auth/me` only checks the session cookie (it does not accept bearer PAT auth).
- `POST /api/v1/auth/logout` is not protected by auth middleware and always returns 204, even if the caller is not authenticated.

This is less about “clean architecture” and more about contract correctness: API contracts (OpenAPI) should match runtime behavior, especially for auth and error shapes.

Evidence:

- OpenAPI security requirements: `backend/openapi.yaml` (operations `/api/v1/auth/me` and `/api/v1/auth/logout`).
- Route wiring (no auth middleware applied to `/auth/*`): `backend/internal/httpapi/routes.go` (route group `r.Route("/auth", ...)`).
- `me` is cookie-only and `logout` is unconditional 204: `backend/internal/httpapi/auth.go` (`handleMe`, `handleLogout`).

### 4) DB types leak into API surface in places

Some HTTP response types directly reference pgx types (example: recipe detail quantity uses `*pgtype.Numeric`).

Even if it currently marshals acceptably, this couples your API contract to a DB driver’s type system and behavior. It also makes it harder to change DB representations or swap drivers without touching the HTTP layer.

Design principle impact:

- Dependency Inversion (in spirit): transport shapes depend on persistence-layer details.

Evidence:

- DB driver type in HTTP DTO: `backend/internal/httpapi/recipes.go` (`recipeIngredientResponse.Quantity *pgtype.Numeric`).

### 5) Two entry points (`cmd/api` and `cmd/cli`) are potentially confusing

`cmd/api` clearly owns the server. `cmd/cli` mixes:

- a “bootstrap user” administrative operation

If `cmd/cli` is intended to become the real admin/ops CLI, it should be made explicit. If not, it risks becoming dead code or confusing new contributors about the canonical binary.

Evidence:

- Mixed concerns in CLI entrypoint: `backend/cmd/cli/main.go` (`bootstrap-user`).

### 6) Schema drift risk: goose migrations vs sqlc schema inputs

The backend currently has two schema inputs:

- Runtime migrations: `backend/migrations/*` applied via goose (see `backend/internal/testutil/pgtest/pgtest.go`).
- sqlc generation schema: `backend/internal/db/schema.sql` (see `backend/sqlc.yaml`).

If these are not generated from a single source of truth, drift is a common failure mode:

- queries compile against schema A but fail at runtime against schema B, or
- migrations introduce constraints/types not reflected in sqlc models and query compilation.

Evidence:

- sqlc schema input is `internal/db/schema.sql`: `backend/sqlc.yaml`.
- Runtime schema changes are via goose migrations: `backend/migrations/*` applied from `backend/internal/testutil/pgtest/pgtest.go` (`MigrateUp`) and located by `backend/internal/migrations/migrations.go` (`Dir`).

### 7) Authorization model is not explicitly defined (highest severity)

Authentication exists (sessions + PAT), but authorization rules are not centrally defined. The most common long-term failure mode is “permissions implemented inconsistently across handlers”.

Missing pieces to make authorization reviewable:

- Ownership rules (e.g., can user A read/modify user B’s recipes/tags/books/users?).
- Admin behaviors (bootstrap implies special cases).
- PAT scope/claims (read-only vs write; token lifecycle and revocation semantics).

Evidence:

- Audit columns exist but are not used for authorization: `backend/internal/db/schema.sql` (`created_by`, `updated_by` on most tables).
- Queries do not scope most resources by user: `backend/internal/db/query/recipes.sql` (`GetRecipeByID`, `UpdateRecipeByID`, `SoftDeleteRecipeByID`, `ListRecipes`); `backend/internal/db/query/tags.sql`; `backend/internal/db/query/recipe_books.sql`.
- Handlers only check authentication, not ownership/role: e.g., `backend/internal/httpapi/recipes_update.go` (`handleRecipesUpdate`), `backend/internal/httpapi/tags.go` (`handleTagsUpdate`/`handleTagsDelete`), `backend/internal/httpapi/users.go` (`handleUsersList`, `handleUsersCreate`).

### 8) CSRF and cookie-session threat surface

Cookie-authenticated unsafe endpoints (POST/PUT/DELETE) are CSRF-relevant unless a defense is explicitly chosen and documented.

The current cookie flags (`SameSite=Lax`, `HttpOnly`) are helpful, but they are not a complete architectural statement on CSRF. This RFC should define whether the app:

- intentionally relies on SameSite constraints (and documents the limitations), or
- implements a dedicated CSRF defense (double-submit or synchronizer token).

Evidence:

- Cookie-auth sessions are used for unsafe methods behind auth middleware: `backend/internal/httpapi/routes.go` (protected routes under `r.Route("/tokens"...)`, `"/tags"`, `"/recipe-books"`, `"/recipes"`).
- Session cookies are set with `SameSite=Lax`: `backend/internal/httpapi/auth.go` (`handleLogin` cookie settings).

### 9) Rate limiting / brute force controls for auth endpoints

There is no documented or enforced strategy for:

- login throttling (per IP / per username),
- token creation throttling,
- account lockouts / exponential backoff.

This is a typical MVP gap that turns into incident fuel later.

Evidence:

- No rate-limit middleware is present in router wiring: `backend/internal/httpapi/routes.go` (middleware list).

### 10) Error taxonomy and internal error leakage risk

Standardizing the response envelope is necessary but not sufficient. The backend also needs:

- stable, documented `code` values for clients,
- a consistent mapping from internal errors to HTTP statuses,
- a single point that decides what gets logged vs returned,
- consistent handling for context cancellation/timeouts (avoid spurious 500s).

Evidence:

- “Problem” envelope exists but handler patterns vary: `backend/internal/httpapi/response/response.go` and `backend/internal/httpapi/session.go` (`writeValidation`).
- Many handlers log internal error details and return a generic message, but mapping is duplicated per handler: e.g., `backend/internal/httpapi/tags.go`, `backend/internal/httpapi/recipes.go`.

### 11) Request parsing hardening (DoS and client correctness)

Not currently addressed as a design decision:

- request body size limits (e.g., `http.MaxBytesReader`),
- strict JSON decoding (`DisallowUnknownFields`) vs permissive decoding (choose deliberately),
- consistent handling of malformed JSON and unexpected fields.
- HTTP server-level timeouts beyond `ReadHeaderTimeout` (e.g., `ReadTimeout`, `WriteTimeout`, `IdleTimeout`) to reduce slow-client/slowloris risk.

Evidence:

- JSON decoding is done without body size limits and without `DisallowUnknownFields`: e.g., `backend/internal/httpapi/auth.go` (`json.NewDecoder(r.Body).Decode`), `backend/internal/httpapi/tags.go`, `backend/internal/httpapi/recipes.go`.
- HTTP server uses `ReadHeaderTimeout` but not other timeouts: `backend/cmd/api/main.go` (`http.Server{ ReadHeaderTimeout: ... }`).

### 12) Observability and auditability gaps

Request logging exists, but the design does not yet define:

- readiness semantics (separate from liveness),
- metrics/tracing expectations,
- audit logging for auth/token lifecycle changes (create/revoke/login/logout).

Evidence:

- Request logging exists: `backend/internal/httpapi/middleware_requestlog.go`.
- Health endpoints exist, but there is no explicit readiness endpoint separate from liveness: `backend/internal/httpapi/routes.go` (`/healthz`, `/api/v1/healthz`).
- Current health handlers do not check DB connectivity (they only return “ok”/`{ok:true}`): `backend/internal/httpapi/routes.go`; a DB ping query exists in sqlc inputs (`backend/internal/db/query/health.sql`) and could be used for readiness if desired.
- DB connectivity is checked at startup via `pgxpool.Ping`: `backend/internal/httpapi/app.go` (`New`).

## Current authorization posture (as implemented)

Based on the current router wiring, handlers, and SQL query shapes, the backend largely behaves as:

- Authentication is required for most resource endpoints (tokens/users/tags/recipe-books/recipes).
- Authorization is mostly “authenticated users can act on global resources by ID” (i.e., there is no ownership scoping in most queries).
- Tokens are the main exception: token list/delete is scoped to the current user ID at the SQL layer.

Concrete observations:

- `users`: any authenticated user can list, create, and deactivate users by ID (no admin/role check).
- `tags` and `recipe-books`: any authenticated user can list/create/update/delete by ID; there is no “owner” concept.
- `recipes`: any authenticated user can list/get/update/delete/restore any recipe by ID; there is no per-user scoping in queries.
- `tokens`: list and delete are scoped to the caller’s user ID in SQL, and bearer auth binds to a user via token hash lookup.

Evidence:

- Route protection (auth required): `backend/internal/httpapi/routes.go` (routes using `r.Use(app.authMiddleware)`).
- Users operations do not enforce roles/ownership: `backend/internal/httpapi/users.go` and `backend/internal/db/query/users.sql`.
- Tags and recipe-books are global-by-ID in SQL: `backend/internal/db/query/tags.sql`, `backend/internal/db/query/recipe_books.sql`.
- Recipes are global-by-ID in SQL: `backend/internal/db/query/recipes.sql` (`GetRecipeByID`, `UpdateRecipeByID`, `SoftDeleteRecipeByID`, `RestoreRecipeByID`).
- Tokens are scoped to user in SQL: `backend/internal/db/query/tokens.sql` (`ListTokensByUser`, `DeleteTokenByIDForUser`).

This posture may be perfectly acceptable for a single-tenant “shared household” app, but it should be an explicit decision (and reflected in tests), because it becomes expensive to change later.

## Decisions required (to make this RFC implementable)

1) Tenant/authorization model:
   - Option A: single-tenant (all authenticated users can manage all resources).
   - Option B: multi-tenant ownership (resources are scoped to a user/household; “admin” is a real role).

2) Auth semantics for `/api/v1/auth/me` and `/api/v1/auth/logout`:
   - Cookie-only vs cookie+bearer; define what “logout” means for bearer auth.

3) CSRF strategy for cookie-authenticated unsafe methods:
   - Explicitly rely on SameSite constraints (and document limitations), or add CSRF tokens.

4) Schema source of truth:
   - Migrations vs `backend/internal/db/schema.sql`, and how CI enforces drift prevention.

5) Error contract:
   - Stable `code` taxonomy, consistent problem envelope, and a single mapping point from internal errors to HTTP responses.

## Risk register (snapshot)

| Risk | Severity | Evidence anchors | Primary remediations |
| --- | --- | --- | --- |
| Global-by-ID authorization may be unintended (especially `/users`) | High | `backend/internal/httpapi/users.go`, `backend/internal/db/query/users.sql`, `backend/internal/httpapi/routes.go` | H, C |
| CSRF exposure for cookie-auth unsafe methods (strategy undefined) | High | `backend/internal/httpapi/auth.go` (cookie settings), `backend/internal/httpapi/routes.go` (cookie-auth protected routes) | H |
| Brute force / abuse of login & token issuance (no throttling) | High | `backend/internal/httpapi/routes.go` (no rate-limit middleware) | H |
| OpenAPI contract drift (auth + error shapes; currently paths-only tests) | High | `backend/openapi.yaml`, `backend/internal/openapi/openapi_test.go`, `backend/internal/httpapi/auth.go` | A, J, B |
| Schema drift between goose migrations and sqlc schema inputs | High | `backend/migrations/*`, `backend/sqlc.yaml`, `backend/internal/db/schema.sql` | G |
| Inconsistent error/validation responses + leakage risk | Medium | `backend/internal/httpapi/response/response.go`, `backend/internal/httpapi/session.go` | B, I |
| Request hardening gaps (size limits, strict JSON, server timeouts) | Medium | `backend/internal/httpapi/*` (decoding), `backend/cmd/api/main.go` (timeouts) | K |
| DB driver types in HTTP DTOs (API coupling) | Low/Medium | `backend/internal/httpapi/recipes.go` (`*pgtype.Numeric`) | D |

## Recommendations (Remediations)

The intent here is incremental improvement without over-engineering.

### A) Align OpenAPI auth semantics with implementation (high priority)

Options (choose one and make both spec + code match):

- If `/auth/me` and `/auth/logout` should accept both cookie sessions and bearer PAT:
  - Put both routes behind `app.authMiddleware` and use `authInfoFromRequest` for identity.
  - Decide what “logout” means for bearer auth (commonly: no-op + 204, or revoke-current-token if token IDs are available).

- If `/auth/me` should be session-only:
  - Update `backend/openapi.yaml` to only include `cookieAuth` for that route.

Outcome:

- Reduces contract drift and security ambiguity.

Addendum (contract enforcement):

- Extend OpenAPI tests beyond “paths exist”: validate status codes, security requirements per operation, and at least one response schema per endpoint.
- Add at least one negative-path contract test per auth endpoint (unauthorized/forbidden) to prevent regressions.

Acceptance criteria:

- OpenAPI `security` requirements for `/api/v1/auth/me` and `/api/v1/auth/logout` match runtime behavior.
- Each auth endpoint has at least one integration test that asserts the unauthorized behavior and response shape.

### B) Standardize problem/validation responses (high priority)

Recommended shape:

- Always use `response.Problem` with `details` as either:
  - `[]response.FieldError` for validation, or
  - `null/omitted` for non-validation errors

Concrete steps:

- Remove or refactor `App.writeValidation` to use `response.WriteValidationProblem` (or a single `App.writeValidationProblem(field, msg)` that emits `[]response.FieldError`).
- Prefer one pattern for “invalid id” and “validation failed” responses across handlers.

Outcome:

- Cleaner client integrations, less repeated glue code, easier OpenAPI maintenance.

Addendum (error taxonomy and leakage control):

- Define stable `code` values (e.g., `validation_error`, `not_found`, `conflict`, `unauthorized`, `forbidden`, `rate_limited`) and document them in OpenAPI.
- Centralize the mapping of internal errors -> (status, problem body, log level) so handlers don’t invent their own semantics.

Acceptance criteria:

- All endpoints emit a single problem envelope shape (`response.Problem`), and validation errors use a single details shape (`[]response.FieldError`).
- OpenAPI documents the problem response schema and stable error codes for each endpoint.

### C) Create a small “application/use-case” seam for complex workflows (medium priority)

For endpoints with transactions and multi-step workflows (recipes create/update is the most obvious), extract use-case functions that take explicit dependencies:

- Inputs: `context`, `*sqlc.Queries`/`DBTX`, `*pgxpool.Pool` or transaction, and a request DTO.
- Output: domain-ish result DTOs that the handler serializes.

This does not require a full domain model. The goal is:

- Keep HTTP concerns (status codes, decoding) in handlers.
- Move workflow orchestration and invariants into testable functions.

Outcome:

- Better SRP, easier unit testing of business rules, reduced handler file growth.

Acceptance criteria:

- Recipe create/update workflows are extracted into use-case functions with fast unit tests for invariants and error mapping.
- Handlers remain transport-focused (decode/validate, call use-case, map typed errors to HTTP).

### D) Reduce DB-driver type leakage in HTTP responses (medium priority)

Prefer API-friendly primitives in response structs:

- Represent numeric quantities as `*string` (decimal) or `*float64` (if loss of precision is acceptable) instead of `*pgtype.Numeric`.
- Keep `pgtype.*` conversions at the boundary between sqlc models and response DTOs.

Outcome:

- Decouples HTTP contract from pgx internals and makes future refactors safer.

Acceptance criteria:

- HTTP request/response DTOs do not expose `pgtype.*` types directly; conversions occur at the persistence boundary.

### G) Make one schema source-of-truth for migrations + sqlc (high priority)

Pick and enforce one source of truth to eliminate schema drift:

- Migrations are source-of-truth (recommended): configure sqlc to read schema from migrations OR generate `internal/db/schema.sql` from migrations in CI and fail on diffs.
- `schema.sql` is source-of-truth: generate migrations from it and fail CI if drift occurs.

Acceptance criteria:

- CI fails if migrations and sqlc schema diverge.
- There is a single documented developer workflow to update schema inputs (no “edit two files by hand”).

### H) Define security model explicitly (high priority)

Document and implement:

- Authorization rules (ownership/admin/scopes) per resource and action.
- CSRF strategy for cookie-authenticated unsafe methods (explicitly choose an approach).
- Rate limiting strategy for login/token endpoints.
- Session and token lifecycle semantics (expiry, rotation/revocation behavior, and whether session expiry is fixed vs sliding).
- Audit logging expectations for auth and token lifecycle events.

Draft authorization matrix (to be confirmed):

| Resource | Action | Anonymous | Authenticated (session) | Authenticated (PAT) | Admin |
| --- | --- | --- | --- | --- | --- |
| auth | login | yes | — | — | — |
| auth | logout | no | yes (cookie) | decision required | yes |
| auth | me | no | yes (cookie) | decision required | yes |
| tokens | list/create/delete | no | yes (own tokens) | yes (own tokens) | yes |
| users | list/create/deactivate | no | yes (current) | yes (current) | yes |
| tags | list/create/update/delete | no | yes | yes | yes |
| recipe-books | list/create/update/delete | no | yes | yes | yes |
| recipes | list/get/create/update/delete/restore | no | yes | yes | yes |

Notes:

- Clarify whether the app is single-tenant (all authenticated users can see/manage all data) or multi-tenant (ownership rules). The current handler patterns should follow the chosen model consistently.
- Current behavior to reconcile with the matrix:
  - `/api/v1/auth/me` currently ignores bearer auth and only checks the session cookie (`backend/internal/httpapi/auth.go`).
  - `/api/v1/auth/logout` currently returns 204 even when unauthenticated (`backend/internal/httpapi/routes.go`, `backend/internal/httpapi/auth.go`).
  - `/api/v1/users/*` is currently accessible to any authenticated principal (session or PAT) (`backend/internal/httpapi/routes.go`, `backend/internal/httpapi/users.go`).
- Clarify auth precedence and semantics when both cookie and bearer auth are present. Current middleware checks bearer first (`backend/internal/httpapi/middleware_auth.go`); the RFC should either codify that or change it intentionally.
- Clarify what `/api/v1/auth/logout` means for bearer auth if bearer auth is supported on that endpoint (no-op vs revoke-current-token vs revoke-all).

Acceptance criteria:

- An authorization matrix exists (resource × action × principal type).
- At least one resource implements the authorization pattern with tests enforcing it.
- CSRF and rate limiting decisions are documented and covered by integration tests for the auth endpoints.

### I) Centralize error mapping and leakage control (medium priority)

Implement a minimal internal error taxonomy and one mapping point:

- typed/sentinel errors for not-found/conflict/forbidden/validation/rate-limited,
- a wrapper type that carries safe public fields (`code`, `message`, `details`) and an underlying cause,
- one function/middleware that maps error -> (status, problem body, log level).

Acceptance criteria:

- A handler can return a typed error and does not need to decide status codes directly.
- Internal causes are logged but not leaked in the HTTP response body.

### J) Strengthen OpenAPI drift defenses (medium priority)

Beyond “required paths”:

- Validate request/response payloads in integration tests against OpenAPI (success and error cases).
- Ensure standardized problem responses are documented and validated.
- Consider generating request/response DTO types from OpenAPI (types-only) while keeping routing/handlers manual.

Acceptance criteria:

- At least one end-to-end request/response validation test exists per tag group (auth, recipes, etc.).

### K) Add request hardening defaults (medium priority)

Add explicit, documented defaults for HTTP robustness:

- Request body size limits on JSON endpoints (via `http.MaxBytesReader`).
- A deliberate stance on unknown JSON fields (`DisallowUnknownFields` for stricter clients, or explicitly allow and document).
- HTTP server timeouts (`ReadTimeout`, `WriteTimeout`, `IdleTimeout`) in addition to `ReadHeaderTimeout`.

Acceptance criteria:

- All JSON endpoints enforce a maximum request size.
- At least one endpoint opts into strict decoding (or the RFC explicitly chooses permissive decoding and documents why).
- `http.Server` timeouts are configured to mitigate slow-client attacks.

### E) Clarify binaries and package roles (low/medium priority)

- If the intended deliverables are “server binary” + “admin CLI”, keep `cmd/api` for the server and `cmd/cli` for administrative operations.

Outcome:

- Lower onboarding friction and clearer operational story.

### F) Keep DRY without over-abstracting (ongoing)

Go’s idiom is to copy small, obvious code rather than build generic frameworks. DRY is most valuable at boundaries (request decoding, validation formatting, response writing, DB error translation). A few small helpers can reduce repetition without hiding logic:

- `decodeJSON(w, r, &dst)` that writes `bad_request` on JSON parse failure.
- `parseUUIDParam(r, "id")` helper used across resources.
- A helper for detecting Postgres unique violations to avoid duplicating `pgErr.Code == "23505"`.

Outcome:

- Keeps handler code compact while staying idiomatic and explicit.

## Tradeoffs and rationale

- This codebase is currently small enough that a “clean architecture” refactor would likely reduce velocity more than it improves quality.
- The highest leverage changes are contract consistency (OpenAPI vs runtime) and response-shape standardization; they provide clear value without structural upheaval.
- Use-case extraction should be driven by complexity hot-spots (transactions, invariants), not applied uniformly across all endpoints.

## Rollout plan (proposed)

1) Decide auth semantics for `/api/v1/auth/me` and `/api/v1/auth/logout` (cookie-only vs cookie+bearer); update OpenAPI + code + tests in lockstep.  
2) Standardize problem responses end-to-end (envelope + stable codes); update OpenAPI and then migrate endpoints incrementally.  
3) Establish schema source-of-truth and add a CI drift check (migrations vs sqlc schema input).  
4) Define an authorization matrix and implement it for one resource as the reference pattern (then extend).  
5) Add CSRF and rate limiting controls for auth endpoints; document operational constraints.  
6) Expand OpenAPI drift tests to cover schemas/status/security (not just “paths exist”).

Backwards compatibility strategy (when changing contracts):

- For error-shape standardization, consider supporting both shapes temporarily (or version within `/api/v1`) if clients are already deployed.
- For auth behavior changes, ensure clients and spec update together; add deprecation notes in OpenAPI if behavior is changing.

## Appendix: Key files and responsibilities

- Server entrypoint: `backend/cmd/api/main.go`
- Router and handlers: `backend/internal/httpapi/*`
- Auth primitives: `backend/internal/auth/*`
- sqlc configuration and schema: `backend/sqlc.yaml` and `backend/internal/db/schema.sql`
- DB access (generated): `backend/internal/db/sqlc/*`
- Migrations: `backend/migrations/*` and `backend/internal/migrations/migrations.go`
- Integration test DB: `backend/internal/testutil/pgtest/pgtest.go`
- OpenAPI spec: `backend/openapi.yaml`
