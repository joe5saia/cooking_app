// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: aisles.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createGroceryAisle = `-- name: CreateGroceryAisle :one
INSERT INTO grocery_aisles (
  name,
  sort_group,
  sort_order,
  numeric_value,
  created_by,
  updated_by
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING id, name, sort_group, sort_order, numeric_value, created_at, created_by, updated_at, updated_by
`

type CreateGroceryAisleParams struct {
	Name         string      `json:"name"`
	SortGroup    int32       `json:"sort_group"`
	SortOrder    int32       `json:"sort_order"`
	NumericValue pgtype.Int4 `json:"numeric_value"`
	CreatedBy    pgtype.UUID `json:"created_by"`
	UpdatedBy    pgtype.UUID `json:"updated_by"`
}

func (q *Queries) CreateGroceryAisle(ctx context.Context, arg CreateGroceryAisleParams) (GroceryAisle, error) {
	row := q.db.QueryRow(ctx, createGroceryAisle,
		arg.Name,
		arg.SortGroup,
		arg.SortOrder,
		arg.NumericValue,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i GroceryAisle
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.SortGroup,
		&i.SortOrder,
		&i.NumericValue,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const deleteGroceryAisleByID = `-- name: DeleteGroceryAisleByID :execrows
DELETE FROM grocery_aisles
WHERE id = $1
`

func (q *Queries) DeleteGroceryAisleByID(ctx context.Context, id pgtype.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteGroceryAisleByID, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getGroceryAisleByID = `-- name: GetGroceryAisleByID :one
SELECT
  id,
  name,
  sort_group,
  sort_order,
  numeric_value,
  created_at,
  created_by,
  updated_at,
  updated_by
FROM grocery_aisles
WHERE id = $1
`

func (q *Queries) GetGroceryAisleByID(ctx context.Context, id pgtype.UUID) (GroceryAisle, error) {
	row := q.db.QueryRow(ctx, getGroceryAisleByID, id)
	var i GroceryAisle
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.SortGroup,
		&i.SortOrder,
		&i.NumericValue,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const listGroceryAisles = `-- name: ListGroceryAisles :many
SELECT
  id,
  name,
  sort_group,
  sort_order,
  numeric_value,
  created_at,
  created_by,
  updated_at,
  updated_by
FROM grocery_aisles
ORDER BY sort_group ASC, sort_order ASC, name ASC
`

func (q *Queries) ListGroceryAisles(ctx context.Context) ([]GroceryAisle, error) {
	rows, err := q.db.Query(ctx, listGroceryAisles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GroceryAisle{}
	for rows.Next() {
		var i GroceryAisle
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.SortGroup,
			&i.SortOrder,
			&i.NumericValue,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGroceryAisleByID = `-- name: UpdateGroceryAisleByID :one
UPDATE grocery_aisles
SET name = $2,
    sort_group = $3,
    sort_order = $4,
    numeric_value = $5,
    updated_at = now(),
    updated_by = $6
WHERE id = $1
RETURNING id, name, sort_group, sort_order, numeric_value, created_at, created_by, updated_at, updated_by
`

type UpdateGroceryAisleByIDParams struct {
	ID           pgtype.UUID `json:"id"`
	Name         string      `json:"name"`
	SortGroup    int32       `json:"sort_group"`
	SortOrder    int32       `json:"sort_order"`
	NumericValue pgtype.Int4 `json:"numeric_value"`
	UpdatedBy    pgtype.UUID `json:"updated_by"`
}

func (q *Queries) UpdateGroceryAisleByID(ctx context.Context, arg UpdateGroceryAisleByIDParams) (GroceryAisle, error) {
	row := q.db.QueryRow(ctx, updateGroceryAisleByID,
		arg.ID,
		arg.Name,
		arg.SortGroup,
		arg.SortOrder,
		arg.NumericValue,
		arg.UpdatedBy,
	)
	var i GroceryAisle
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.SortGroup,
		&i.SortOrder,
		&i.NumericValue,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}
