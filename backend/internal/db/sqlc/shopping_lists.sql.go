// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: shopping_lists.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createShoppingList = `-- name: CreateShoppingList :one
INSERT INTO shopping_lists (
  list_date,
  name,
  notes,
  created_by,
  updated_by
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5
)
RETURNING id, list_date, name, notes, created_at, updated_at
`

type CreateShoppingListParams struct {
	ListDate  pgtype.Date `json:"list_date"`
	Name      string      `json:"name"`
	Notes     pgtype.Text `json:"notes"`
	CreatedBy pgtype.UUID `json:"created_by"`
	UpdatedBy pgtype.UUID `json:"updated_by"`
}

type CreateShoppingListRow struct {
	ID        pgtype.UUID        `json:"id"`
	ListDate  pgtype.Date        `json:"list_date"`
	Name      string             `json:"name"`
	Notes     pgtype.Text        `json:"notes"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateShoppingList(ctx context.Context, arg CreateShoppingListParams) (CreateShoppingListRow, error) {
	row := q.db.QueryRow(ctx, createShoppingList,
		arg.ListDate,
		arg.Name,
		arg.Notes,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i CreateShoppingListRow
	err := row.Scan(
		&i.ID,
		&i.ListDate,
		&i.Name,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteShoppingListByID = `-- name: DeleteShoppingListByID :execrows
DELETE FROM shopping_lists
WHERE id = $1
  AND created_by = $2
`

type DeleteShoppingListByIDParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) DeleteShoppingListByID(ctx context.Context, arg DeleteShoppingListByIDParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteShoppingListByID, arg.ID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getShoppingListByID = `-- name: GetShoppingListByID :one
SELECT
  id,
  list_date,
  name,
  notes,
  created_at,
  updated_at
FROM shopping_lists
WHERE id = $1
  AND created_by = $2
`

type GetShoppingListByIDParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

type GetShoppingListByIDRow struct {
	ID        pgtype.UUID        `json:"id"`
	ListDate  pgtype.Date        `json:"list_date"`
	Name      string             `json:"name"`
	Notes     pgtype.Text        `json:"notes"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetShoppingListByID(ctx context.Context, arg GetShoppingListByIDParams) (GetShoppingListByIDRow, error) {
	row := q.db.QueryRow(ctx, getShoppingListByID, arg.ID, arg.UserID)
	var i GetShoppingListByIDRow
	err := row.Scan(
		&i.ID,
		&i.ListDate,
		&i.Name,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listShoppingListsByDateRange = `-- name: ListShoppingListsByDateRange :many
SELECT
  id,
  list_date,
  name,
  notes,
  created_at,
  updated_at
FROM shopping_lists
WHERE created_by = $1
  AND list_date >= $2
  AND list_date <= $3
ORDER BY list_date ASC, created_at ASC
`

type ListShoppingListsByDateRangeParams struct {
	UserID    pgtype.UUID `json:"user_id"`
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
}

type ListShoppingListsByDateRangeRow struct {
	ID        pgtype.UUID        `json:"id"`
	ListDate  pgtype.Date        `json:"list_date"`
	Name      string             `json:"name"`
	Notes     pgtype.Text        `json:"notes"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListShoppingListsByDateRange(ctx context.Context, arg ListShoppingListsByDateRangeParams) ([]ListShoppingListsByDateRangeRow, error) {
	rows, err := q.db.Query(ctx, listShoppingListsByDateRange, arg.UserID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListShoppingListsByDateRangeRow{}
	for rows.Next() {
		var i ListShoppingListsByDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.ListDate,
			&i.Name,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateShoppingListByID = `-- name: UpdateShoppingListByID :one
UPDATE shopping_lists
SET list_date = $1,
    name = $2,
    notes = $3,
    updated_at = now(),
    updated_by = $4
WHERE id = $5
  AND created_by = $6
RETURNING id, list_date, name, notes, created_at, updated_at
`

type UpdateShoppingListByIDParams struct {
	ListDate  pgtype.Date `json:"list_date"`
	Name      string      `json:"name"`
	Notes     pgtype.Text `json:"notes"`
	UpdatedBy pgtype.UUID `json:"updated_by"`
	ID        pgtype.UUID `json:"id"`
	UserID    pgtype.UUID `json:"user_id"`
}

type UpdateShoppingListByIDRow struct {
	ID        pgtype.UUID        `json:"id"`
	ListDate  pgtype.Date        `json:"list_date"`
	Name      string             `json:"name"`
	Notes     pgtype.Text        `json:"notes"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateShoppingListByID(ctx context.Context, arg UpdateShoppingListByIDParams) (UpdateShoppingListByIDRow, error) {
	row := q.db.QueryRow(ctx, updateShoppingListByID,
		arg.ListDate,
		arg.Name,
		arg.Notes,
		arg.UpdatedBy,
		arg.ID,
		arg.UserID,
	)
	var i UpdateShoppingListByIDRow
	err := row.Scan(
		&i.ID,
		&i.ListDate,
		&i.Name,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
