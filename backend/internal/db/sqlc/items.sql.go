// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: items.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createItem = `-- name: CreateItem :one
INSERT INTO items (
  name,
  store_url,
  aisle_id,
  created_by,
  updated_by
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id, name, store_url, aisle_id, created_at, created_by, updated_at, updated_by
`

type CreateItemParams struct {
	Name      string      `json:"name"`
	StoreUrl  pgtype.Text `json:"store_url"`
	AisleID   pgtype.UUID `json:"aisle_id"`
	CreatedBy pgtype.UUID `json:"created_by"`
	UpdatedBy pgtype.UUID `json:"updated_by"`
}

func (q *Queries) CreateItem(ctx context.Context, arg CreateItemParams) (Item, error) {
	row := q.db.QueryRow(ctx, createItem,
		arg.Name,
		arg.StoreUrl,
		arg.AisleID,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.StoreUrl,
		&i.AisleID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const deleteItemByID = `-- name: DeleteItemByID :execrows
DELETE FROM items
WHERE id = $1
`

func (q *Queries) DeleteItemByID(ctx context.Context, id pgtype.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteItemByID, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getItemByID = `-- name: GetItemByID :one
SELECT
  i.id,
  i.name,
  i.store_url,
  i.aisle_id,
  a.name AS aisle_name,
  a.sort_group AS aisle_sort_group,
  a.sort_order AS aisle_sort_order,
  a.numeric_value AS aisle_numeric_value,
  i.created_at,
  i.created_by,
  i.updated_at,
  i.updated_by
FROM items i
LEFT JOIN grocery_aisles a ON a.id = i.aisle_id
WHERE i.id = $1
`

type GetItemByIDRow struct {
	ID                pgtype.UUID        `json:"id"`
	Name              string             `json:"name"`
	StoreUrl          pgtype.Text        `json:"store_url"`
	AisleID           pgtype.UUID        `json:"aisle_id"`
	AisleName         pgtype.Text        `json:"aisle_name"`
	AisleSortGroup    pgtype.Int4        `json:"aisle_sort_group"`
	AisleSortOrder    pgtype.Int4        `json:"aisle_sort_order"`
	AisleNumericValue pgtype.Int4        `json:"aisle_numeric_value"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	CreatedBy         pgtype.UUID        `json:"created_by"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	UpdatedBy         pgtype.UUID        `json:"updated_by"`
}

func (q *Queries) GetItemByID(ctx context.Context, id pgtype.UUID) (GetItemByIDRow, error) {
	row := q.db.QueryRow(ctx, getItemByID, id)
	var i GetItemByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.StoreUrl,
		&i.AisleID,
		&i.AisleName,
		&i.AisleSortGroup,
		&i.AisleSortOrder,
		&i.AisleNumericValue,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const getItemByName = `-- name: GetItemByName :one
SELECT
  id,
  name,
  store_url,
  aisle_id,
  created_at,
  created_by,
  updated_at,
  updated_by
FROM items
WHERE name = $1
`

func (q *Queries) GetItemByName(ctx context.Context, name string) (Item, error) {
	row := q.db.QueryRow(ctx, getItemByName, name)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.StoreUrl,
		&i.AisleID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const listItems = `-- name: ListItems :many
SELECT
  i.id,
  i.name,
  i.store_url,
  i.aisle_id,
  a.name AS aisle_name,
  a.sort_group AS aisle_sort_group,
  a.sort_order AS aisle_sort_order,
  a.numeric_value AS aisle_numeric_value,
  i.created_at,
  i.created_by,
  i.updated_at,
  i.updated_by
FROM items i
LEFT JOIN grocery_aisles a ON a.id = i.aisle_id
WHERE ($1::text = '' OR i.name ILIKE ('%' || $1::text || '%'))
ORDER BY i.name ASC
LIMIT $2
`

type ListItemsParams struct {
	Q         string `json:"q"`
	PageLimit int32  `json:"page_limit"`
}

type ListItemsRow struct {
	ID                pgtype.UUID        `json:"id"`
	Name              string             `json:"name"`
	StoreUrl          pgtype.Text        `json:"store_url"`
	AisleID           pgtype.UUID        `json:"aisle_id"`
	AisleName         pgtype.Text        `json:"aisle_name"`
	AisleSortGroup    pgtype.Int4        `json:"aisle_sort_group"`
	AisleSortOrder    pgtype.Int4        `json:"aisle_sort_order"`
	AisleNumericValue pgtype.Int4        `json:"aisle_numeric_value"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	CreatedBy         pgtype.UUID        `json:"created_by"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	UpdatedBy         pgtype.UUID        `json:"updated_by"`
}

func (q *Queries) ListItems(ctx context.Context, arg ListItemsParams) ([]ListItemsRow, error) {
	rows, err := q.db.Query(ctx, listItems, arg.Q, arg.PageLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListItemsRow{}
	for rows.Next() {
		var i ListItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.StoreUrl,
			&i.AisleID,
			&i.AisleName,
			&i.AisleSortGroup,
			&i.AisleSortOrder,
			&i.AisleNumericValue,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateItemByID = `-- name: UpdateItemByID :one
UPDATE items
SET name = $2,
    store_url = $3,
    aisle_id = $4,
    updated_at = now(),
    updated_by = $5
WHERE id = $1
RETURNING id, name, store_url, aisle_id, created_at, created_by, updated_at, updated_by
`

type UpdateItemByIDParams struct {
	ID        pgtype.UUID `json:"id"`
	Name      string      `json:"name"`
	StoreUrl  pgtype.Text `json:"store_url"`
	AisleID   pgtype.UUID `json:"aisle_id"`
	UpdatedBy pgtype.UUID `json:"updated_by"`
}

func (q *Queries) UpdateItemByID(ctx context.Context, arg UpdateItemByIDParams) (Item, error) {
	row := q.db.QueryRow(ctx, updateItemByID,
		arg.ID,
		arg.Name,
		arg.StoreUrl,
		arg.AisleID,
		arg.UpdatedBy,
	)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.StoreUrl,
		&i.AisleID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}
