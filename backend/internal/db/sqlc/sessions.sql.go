// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sessions.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (
  user_id,
  token_hash,
  expires_at,
  last_seen_at,
  created_by,
  updated_by
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING id, user_id, token_hash, expires_at, last_seen_at, created_at, created_by, updated_at, updated_by
`

type CreateSessionParams struct {
	UserID     pgtype.UUID        `json:"user_id"`
	TokenHash  []byte             `json:"token_hash"`
	ExpiresAt  pgtype.Timestamptz `json:"expires_at"`
	LastSeenAt pgtype.Timestamptz `json:"last_seen_at"`
	CreatedBy  pgtype.UUID        `json:"created_by"`
	UpdatedBy  pgtype.UUID        `json:"updated_by"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, createSession,
		arg.UserID,
		arg.TokenHash,
		arg.ExpiresAt,
		arg.LastSeenAt,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.LastSeenAt,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const deleteSessionByTokenHash = `-- name: DeleteSessionByTokenHash :exec
DELETE FROM sessions
WHERE token_hash = $1
`

func (q *Queries) DeleteSessionByTokenHash(ctx context.Context, tokenHash []byte) error {
	_, err := q.db.Exec(ctx, deleteSessionByTokenHash, tokenHash)
	return err
}

const getSessionUserByTokenHash = `-- name: GetSessionUserByTokenHash :one
SELECT
  s.id as session_id,
  s.user_id as session_user_id,
  s.expires_at as session_expires_at,
  s.last_seen_at as session_last_seen_at,
  u.id as user_id,
  u.username as username,
  u.display_name as display_name,
  u.is_active as is_active
FROM sessions s
JOIN users u ON u.id = s.user_id
WHERE s.token_hash = $1
`

type GetSessionUserByTokenHashRow struct {
	SessionID         pgtype.UUID        `json:"session_id"`
	SessionUserID     pgtype.UUID        `json:"session_user_id"`
	SessionExpiresAt  pgtype.Timestamptz `json:"session_expires_at"`
	SessionLastSeenAt pgtype.Timestamptz `json:"session_last_seen_at"`
	UserID            pgtype.UUID        `json:"user_id"`
	Username          string             `json:"username"`
	DisplayName       pgtype.Text        `json:"display_name"`
	IsActive          bool               `json:"is_active"`
}

func (q *Queries) GetSessionUserByTokenHash(ctx context.Context, tokenHash []byte) (GetSessionUserByTokenHashRow, error) {
	row := q.db.QueryRow(ctx, getSessionUserByTokenHash, tokenHash)
	var i GetSessionUserByTokenHashRow
	err := row.Scan(
		&i.SessionID,
		&i.SessionUserID,
		&i.SessionExpiresAt,
		&i.SessionLastSeenAt,
		&i.UserID,
		&i.Username,
		&i.DisplayName,
		&i.IsActive,
	)
	return i, err
}
