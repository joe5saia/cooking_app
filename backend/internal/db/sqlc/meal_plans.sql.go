// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: meal_plans.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMealPlanEntry = `-- name: CreateMealPlanEntry :one
WITH candidate AS (
  SELECT
    r.id AS recipe_id,
    r.title
  FROM recipes r
  WHERE r.id = $1
    AND r.deleted_at IS NULL
),
inserted AS (
  INSERT INTO meal_plan_entries (
    user_id,
    plan_date,
    recipe_id,
    created_by,
    updated_by
  )
  SELECT
    $2,
    $3,
    c.recipe_id,
    $4,
    $5
  FROM candidate c
  RETURNING id, plan_date, recipe_id
)
SELECT
  inserted.id,
  inserted.plan_date,
  inserted.recipe_id,
  c.title
FROM inserted
JOIN candidate c ON c.recipe_id = inserted.recipe_id
`

type CreateMealPlanEntryParams struct {
	RecipeID  pgtype.UUID `json:"recipe_id"`
	UserID    pgtype.UUID `json:"user_id"`
	PlanDate  pgtype.Date `json:"plan_date"`
	CreatedBy pgtype.UUID `json:"created_by"`
	UpdatedBy pgtype.UUID `json:"updated_by"`
}

type CreateMealPlanEntryRow struct {
	ID       pgtype.UUID `json:"id"`
	PlanDate pgtype.Date `json:"plan_date"`
	RecipeID pgtype.UUID `json:"recipe_id"`
	Title    string      `json:"title"`
}

func (q *Queries) CreateMealPlanEntry(ctx context.Context, arg CreateMealPlanEntryParams) (CreateMealPlanEntryRow, error) {
	row := q.db.QueryRow(ctx, createMealPlanEntry,
		arg.RecipeID,
		arg.UserID,
		arg.PlanDate,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i CreateMealPlanEntryRow
	err := row.Scan(
		&i.ID,
		&i.PlanDate,
		&i.RecipeID,
		&i.Title,
	)
	return i, err
}

const deleteMealPlanEntry = `-- name: DeleteMealPlanEntry :execrows
DELETE FROM meal_plan_entries
WHERE user_id = $1
  AND plan_date = $2
  AND recipe_id = $3
`

type DeleteMealPlanEntryParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	PlanDate pgtype.Date `json:"plan_date"`
	RecipeID pgtype.UUID `json:"recipe_id"`
}

func (q *Queries) DeleteMealPlanEntry(ctx context.Context, arg DeleteMealPlanEntryParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteMealPlanEntry, arg.UserID, arg.PlanDate, arg.RecipeID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const listMealPlanEntriesByRange = `-- name: ListMealPlanEntriesByRange :many
SELECT
  mpe.id,
  mpe.plan_date,
  mpe.recipe_id,
  r.title
FROM meal_plan_entries mpe
JOIN recipes r ON r.id = mpe.recipe_id
WHERE mpe.user_id = $1
  AND mpe.plan_date >= $2
  AND mpe.plan_date <= $3
  AND r.deleted_at IS NULL
ORDER BY mpe.plan_date ASC, mpe.created_at ASC
`

type ListMealPlanEntriesByRangeParams struct {
	UserID    pgtype.UUID `json:"user_id"`
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
}

type ListMealPlanEntriesByRangeRow struct {
	ID       pgtype.UUID `json:"id"`
	PlanDate pgtype.Date `json:"plan_date"`
	RecipeID pgtype.UUID `json:"recipe_id"`
	Title    string      `json:"title"`
}

func (q *Queries) ListMealPlanEntriesByRange(ctx context.Context, arg ListMealPlanEntriesByRangeParams) ([]ListMealPlanEntriesByRangeRow, error) {
	rows, err := q.db.Query(ctx, listMealPlanEntriesByRange, arg.UserID, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMealPlanEntriesByRangeRow{}
	for rows.Next() {
		var i ListMealPlanEntriesByRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.PlanDate,
			&i.RecipeID,
			&i.Title,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
