// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: shopping_list_items.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteShoppingListItemByID = `-- name: DeleteShoppingListItemByID :execrows
DELETE FROM shopping_list_items sli
USING shopping_lists sl
WHERE sli.id = $1
  AND sli.shopping_list_id = $2
  AND sli.shopping_list_id = sl.id
  AND sl.created_by = $3
`

type DeleteShoppingListItemByIDParams struct {
	ID             pgtype.UUID `json:"id"`
	ShoppingListID pgtype.UUID `json:"shopping_list_id"`
	UserID         pgtype.UUID `json:"user_id"`
}

func (q *Queries) DeleteShoppingListItemByID(ctx context.Context, arg DeleteShoppingListItemByIDParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteShoppingListItemByID, arg.ID, arg.ShoppingListID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const listRecipeIngredientsByMealPlanDate = `-- name: ListRecipeIngredientsByMealPlanDate :many
SELECT
  ri.item_id,
  ri.quantity,
  ri.quantity_text,
  ri.unit
FROM meal_plan_entries mpe
JOIN recipes r ON r.id = mpe.recipe_id
JOIN recipe_ingredients ri ON ri.recipe_id = r.id
WHERE mpe.user_id = $1
  AND mpe.plan_date = $2
  AND r.deleted_at IS NULL
ORDER BY mpe.plan_date ASC, ri.position ASC
`

type ListRecipeIngredientsByMealPlanDateParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	PlanDate pgtype.Date `json:"plan_date"`
}

type ListRecipeIngredientsByMealPlanDateRow struct {
	ItemID       pgtype.UUID    `json:"item_id"`
	Quantity     pgtype.Numeric `json:"quantity"`
	QuantityText pgtype.Text    `json:"quantity_text"`
	Unit         pgtype.Text    `json:"unit"`
}

func (q *Queries) ListRecipeIngredientsByMealPlanDate(ctx context.Context, arg ListRecipeIngredientsByMealPlanDateParams) ([]ListRecipeIngredientsByMealPlanDateRow, error) {
	rows, err := q.db.Query(ctx, listRecipeIngredientsByMealPlanDate, arg.UserID, arg.PlanDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRecipeIngredientsByMealPlanDateRow{}
	for rows.Next() {
		var i ListRecipeIngredientsByMealPlanDateRow
		if err := rows.Scan(
			&i.ItemID,
			&i.Quantity,
			&i.QuantityText,
			&i.Unit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecipeIngredientsByRecipeIDs = `-- name: ListRecipeIngredientsByRecipeIDs :many
SELECT
  ri.item_id,
  ri.quantity,
  ri.quantity_text,
  ri.unit
FROM recipe_ingredients ri
JOIN recipes r ON r.id = ri.recipe_id
WHERE ri.recipe_id = ANY($1::uuid[])
  AND r.deleted_at IS NULL
ORDER BY ri.recipe_id ASC, ri.position ASC
`

type ListRecipeIngredientsByRecipeIDsRow struct {
	ItemID       pgtype.UUID    `json:"item_id"`
	Quantity     pgtype.Numeric `json:"quantity"`
	QuantityText pgtype.Text    `json:"quantity_text"`
	Unit         pgtype.Text    `json:"unit"`
}

func (q *Queries) ListRecipeIngredientsByRecipeIDs(ctx context.Context, recipeIds []pgtype.UUID) ([]ListRecipeIngredientsByRecipeIDsRow, error) {
	rows, err := q.db.Query(ctx, listRecipeIngredientsByRecipeIDs, recipeIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRecipeIngredientsByRecipeIDsRow{}
	for rows.Next() {
		var i ListRecipeIngredientsByRecipeIDsRow
		if err := rows.Scan(
			&i.ItemID,
			&i.Quantity,
			&i.QuantityText,
			&i.Unit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listShoppingListItemsByListID = `-- name: ListShoppingListItemsByListID :many
SELECT
  sli.id,
  sli.shopping_list_id,
  sli.item_id,
  sli.unit,
  sli.quantity,
  sli.quantity_text,
  sli.is_purchased,
  sli.purchased_at,
  i.name AS item_name,
  i.store_url AS item_store_url,
  i.aisle_id AS item_aisle_id,
  a.name AS aisle_name,
  a.sort_group AS aisle_sort_group,
  a.sort_order AS aisle_sort_order,
  a.numeric_value AS aisle_numeric_value
FROM shopping_list_items sli
JOIN shopping_lists sl ON sl.id = sli.shopping_list_id
JOIN items i ON i.id = sli.item_id
LEFT JOIN grocery_aisles a ON a.id = i.aisle_id
WHERE sli.shopping_list_id = $1
  AND sl.created_by = $2
ORDER BY
  COALESCE(a.sort_group, 2) ASC,
  COALESCE(a.sort_order, 0) ASC,
  COALESCE(a.numeric_value, 0) ASC,
  a.name ASC,
  i.name ASC
`

type ListShoppingListItemsByListIDParams struct {
	ShoppingListID pgtype.UUID `json:"shopping_list_id"`
	UserID         pgtype.UUID `json:"user_id"`
}

type ListShoppingListItemsByListIDRow struct {
	ID                pgtype.UUID        `json:"id"`
	ShoppingListID    pgtype.UUID        `json:"shopping_list_id"`
	ItemID            pgtype.UUID        `json:"item_id"`
	Unit              pgtype.Text        `json:"unit"`
	Quantity          pgtype.Numeric     `json:"quantity"`
	QuantityText      pgtype.Text        `json:"quantity_text"`
	IsPurchased       bool               `json:"is_purchased"`
	PurchasedAt       pgtype.Timestamptz `json:"purchased_at"`
	ItemName          string             `json:"item_name"`
	ItemStoreUrl      pgtype.Text        `json:"item_store_url"`
	ItemAisleID       pgtype.UUID        `json:"item_aisle_id"`
	AisleName         pgtype.Text        `json:"aisle_name"`
	AisleSortGroup    pgtype.Int4        `json:"aisle_sort_group"`
	AisleSortOrder    pgtype.Int4        `json:"aisle_sort_order"`
	AisleNumericValue pgtype.Int4        `json:"aisle_numeric_value"`
}

func (q *Queries) ListShoppingListItemsByListID(ctx context.Context, arg ListShoppingListItemsByListIDParams) ([]ListShoppingListItemsByListIDRow, error) {
	rows, err := q.db.Query(ctx, listShoppingListItemsByListID, arg.ShoppingListID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListShoppingListItemsByListIDRow{}
	for rows.Next() {
		var i ListShoppingListItemsByListIDRow
		if err := rows.Scan(
			&i.ID,
			&i.ShoppingListID,
			&i.ItemID,
			&i.Unit,
			&i.Quantity,
			&i.QuantityText,
			&i.IsPurchased,
			&i.PurchasedAt,
			&i.ItemName,
			&i.ItemStoreUrl,
			&i.ItemAisleID,
			&i.AisleName,
			&i.AisleSortGroup,
			&i.AisleSortOrder,
			&i.AisleNumericValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateShoppingListItemPurchased = `-- name: UpdateShoppingListItemPurchased :one
UPDATE shopping_list_items AS sli
SET is_purchased = $1,
    purchased_at = CASE WHEN $1 THEN now() ELSE NULL END,
    updated_at = now(),
    updated_by = $2
FROM shopping_lists sl
JOIN items i ON i.id = sli.item_id
LEFT JOIN grocery_aisles a ON a.id = i.aisle_id
WHERE sli.id = $3
  AND sli.shopping_list_id = $4
  AND sli.shopping_list_id = sl.id
  AND sl.created_by = $5
RETURNING
  sli.id,
  sli.shopping_list_id,
  sli.item_id,
  sli.unit,
  sli.quantity,
  sli.quantity_text,
  sli.is_purchased,
  sli.purchased_at,
  i.name AS item_name,
  i.store_url AS item_store_url,
  i.aisle_id AS item_aisle_id,
  a.name AS aisle_name,
  a.sort_group AS aisle_sort_group,
  a.sort_order AS aisle_sort_order,
  a.numeric_value AS aisle_numeric_value
`

type UpdateShoppingListItemPurchasedParams struct {
	IsPurchased    bool        `json:"is_purchased"`
	UpdatedBy      pgtype.UUID `json:"updated_by"`
	ID             pgtype.UUID `json:"id"`
	ShoppingListID pgtype.UUID `json:"shopping_list_id"`
	UserID         pgtype.UUID `json:"user_id"`
}

type UpdateShoppingListItemPurchasedRow struct {
	ID                pgtype.UUID        `json:"id"`
	ShoppingListID    pgtype.UUID        `json:"shopping_list_id"`
	ItemID            pgtype.UUID        `json:"item_id"`
	Unit              pgtype.Text        `json:"unit"`
	Quantity          pgtype.Numeric     `json:"quantity"`
	QuantityText      pgtype.Text        `json:"quantity_text"`
	IsPurchased       bool               `json:"is_purchased"`
	PurchasedAt       pgtype.Timestamptz `json:"purchased_at"`
	ItemName          string             `json:"item_name"`
	ItemStoreUrl      pgtype.Text        `json:"item_store_url"`
	ItemAisleID       pgtype.UUID        `json:"item_aisle_id"`
	AisleName         string             `json:"aisle_name"`
	AisleSortGroup    int32              `json:"aisle_sort_group"`
	AisleSortOrder    int32              `json:"aisle_sort_order"`
	AisleNumericValue pgtype.Int4        `json:"aisle_numeric_value"`
}

func (q *Queries) UpdateShoppingListItemPurchased(ctx context.Context, arg UpdateShoppingListItemPurchasedParams) (UpdateShoppingListItemPurchasedRow, error) {
	row := q.db.QueryRow(ctx, updateShoppingListItemPurchased,
		arg.IsPurchased,
		arg.UpdatedBy,
		arg.ID,
		arg.ShoppingListID,
		arg.UserID,
	)
	var i UpdateShoppingListItemPurchasedRow
	err := row.Scan(
		&i.ID,
		&i.ShoppingListID,
		&i.ItemID,
		&i.Unit,
		&i.Quantity,
		&i.QuantityText,
		&i.IsPurchased,
		&i.PurchasedAt,
		&i.ItemName,
		&i.ItemStoreUrl,
		&i.ItemAisleID,
		&i.AisleName,
		&i.AisleSortGroup,
		&i.AisleSortOrder,
		&i.AisleNumericValue,
	)
	return i, err
}

const upsertShoppingListItem = `-- name: UpsertShoppingListItem :one
WITH list_scope AS (
  SELECT sl.id
  FROM shopping_lists sl
  WHERE sl.id = $7
    AND sl.created_by = $8
)
INSERT INTO shopping_list_items (
  shopping_list_id,
  item_id,
  unit,
  quantity,
  quantity_text,
  is_purchased,
  purchased_at,
  created_by,
  updated_by
)
SELECT
  list_scope.id,
  $1,
  $2,
  $3,
  $4,
  false,
  NULL,
  $5,
  $6
FROM list_scope
ON CONFLICT (shopping_list_id, item_id, unit) DO UPDATE
SET quantity = CASE
    WHEN shopping_list_items.quantity IS NULL AND EXCLUDED.quantity IS NULL THEN NULL
    WHEN shopping_list_items.quantity IS NULL THEN EXCLUDED.quantity
    WHEN EXCLUDED.quantity IS NULL THEN shopping_list_items.quantity
    ELSE shopping_list_items.quantity + EXCLUDED.quantity
  END,
  quantity_text = COALESCE(EXCLUDED.quantity_text, shopping_list_items.quantity_text),
  is_purchased = false,
  purchased_at = NULL,
  updated_at = now(),
  updated_by = EXCLUDED.updated_by
RETURNING id, shopping_list_id, item_id, unit, quantity, quantity_text, is_purchased, purchased_at
`

type UpsertShoppingListItemParams struct {
	ItemID         pgtype.UUID    `json:"item_id"`
	Unit           pgtype.Text    `json:"unit"`
	Quantity       pgtype.Numeric `json:"quantity"`
	QuantityText   pgtype.Text    `json:"quantity_text"`
	CreatedBy      pgtype.UUID    `json:"created_by"`
	UpdatedBy      pgtype.UUID    `json:"updated_by"`
	ShoppingListID pgtype.UUID    `json:"shopping_list_id"`
	UserID         pgtype.UUID    `json:"user_id"`
}

type UpsertShoppingListItemRow struct {
	ID             pgtype.UUID        `json:"id"`
	ShoppingListID pgtype.UUID        `json:"shopping_list_id"`
	ItemID         pgtype.UUID        `json:"item_id"`
	Unit           pgtype.Text        `json:"unit"`
	Quantity       pgtype.Numeric     `json:"quantity"`
	QuantityText   pgtype.Text        `json:"quantity_text"`
	IsPurchased    bool               `json:"is_purchased"`
	PurchasedAt    pgtype.Timestamptz `json:"purchased_at"`
}

func (q *Queries) UpsertShoppingListItem(ctx context.Context, arg UpsertShoppingListItemParams) (UpsertShoppingListItemRow, error) {
	row := q.db.QueryRow(ctx, upsertShoppingListItem,
		arg.ItemID,
		arg.Unit,
		arg.Quantity,
		arg.QuantityText,
		arg.CreatedBy,
		arg.UpdatedBy,
		arg.ShoppingListID,
		arg.UserID,
	)
	var i UpsertShoppingListItemRow
	err := row.Scan(
		&i.ID,
		&i.ShoppingListID,
		&i.ItemID,
		&i.Unit,
		&i.Quantity,
		&i.QuantityText,
		&i.IsPurchased,
		&i.PurchasedAt,
	)
	return i, err
}
