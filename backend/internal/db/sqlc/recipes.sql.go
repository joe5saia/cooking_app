// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: recipes.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countTagsByIDs = `-- name: CountTagsByIDs :one
SELECT COUNT(*)::int AS count
FROM tags
WHERE id = ANY($1::uuid[])
`

func (q *Queries) CountTagsByIDs(ctx context.Context, dollar_1 []pgtype.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, countTagsByIDs, dollar_1)
	var count int32
	err := row.Scan(&count)
	return count, err
}

const createRecipe = `-- name: CreateRecipe :one
INSERT INTO recipes (
  title,
  servings,
  prep_time_minutes,
  total_time_minutes,
  source_url,
  notes,
  recipe_book_id,
  deleted_at,
  created_by,
  updated_by
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, NULL, $8, $9
)
RETURNING id, title, servings, prep_time_minutes, total_time_minutes, source_url, notes, recipe_book_id, deleted_at, created_at, created_by, updated_at, updated_by
`

type CreateRecipeParams struct {
	Title            string      `json:"title"`
	Servings         int32       `json:"servings"`
	PrepTimeMinutes  int32       `json:"prep_time_minutes"`
	TotalTimeMinutes int32       `json:"total_time_minutes"`
	SourceUrl        pgtype.Text `json:"source_url"`
	Notes            pgtype.Text `json:"notes"`
	RecipeBookID     pgtype.UUID `json:"recipe_book_id"`
	CreatedBy        pgtype.UUID `json:"created_by"`
	UpdatedBy        pgtype.UUID `json:"updated_by"`
}

func (q *Queries) CreateRecipe(ctx context.Context, arg CreateRecipeParams) (Recipe, error) {
	row := q.db.QueryRow(ctx, createRecipe,
		arg.Title,
		arg.Servings,
		arg.PrepTimeMinutes,
		arg.TotalTimeMinutes,
		arg.SourceUrl,
		arg.Notes,
		arg.RecipeBookID,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Servings,
		&i.PrepTimeMinutes,
		&i.TotalTimeMinutes,
		&i.SourceUrl,
		&i.Notes,
		&i.RecipeBookID,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const createRecipeIngredient = `-- name: CreateRecipeIngredient :exec
INSERT INTO recipe_ingredients (
  recipe_id,
  position,
  quantity,
  quantity_text,
  unit,
  item_id,
  prep,
  notes,
  original_text,
  created_by,
  updated_by
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
)
`

type CreateRecipeIngredientParams struct {
	RecipeID     pgtype.UUID    `json:"recipe_id"`
	Position     int32          `json:"position"`
	Quantity     pgtype.Numeric `json:"quantity"`
	QuantityText pgtype.Text    `json:"quantity_text"`
	Unit         pgtype.Text    `json:"unit"`
	ItemID       pgtype.UUID    `json:"item_id"`
	Prep         pgtype.Text    `json:"prep"`
	Notes        pgtype.Text    `json:"notes"`
	OriginalText pgtype.Text    `json:"original_text"`
	CreatedBy    pgtype.UUID    `json:"created_by"`
	UpdatedBy    pgtype.UUID    `json:"updated_by"`
}

func (q *Queries) CreateRecipeIngredient(ctx context.Context, arg CreateRecipeIngredientParams) error {
	_, err := q.db.Exec(ctx, createRecipeIngredient,
		arg.RecipeID,
		arg.Position,
		arg.Quantity,
		arg.QuantityText,
		arg.Unit,
		arg.ItemID,
		arg.Prep,
		arg.Notes,
		arg.OriginalText,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	return err
}

const createRecipeStep = `-- name: CreateRecipeStep :exec
INSERT INTO recipe_steps (
  recipe_id,
  step_number,
  instruction,
  created_by,
  updated_by
) VALUES (
  $1, $2, $3, $4, $5
)
`

type CreateRecipeStepParams struct {
	RecipeID    pgtype.UUID `json:"recipe_id"`
	StepNumber  int32       `json:"step_number"`
	Instruction string      `json:"instruction"`
	CreatedBy   pgtype.UUID `json:"created_by"`
	UpdatedBy   pgtype.UUID `json:"updated_by"`
}

func (q *Queries) CreateRecipeStep(ctx context.Context, arg CreateRecipeStepParams) error {
	_, err := q.db.Exec(ctx, createRecipeStep,
		arg.RecipeID,
		arg.StepNumber,
		arg.Instruction,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	return err
}

const createRecipeTag = `-- name: CreateRecipeTag :exec
INSERT INTO recipe_tags (
  recipe_id,
  tag_id,
  created_by,
  updated_by
) VALUES (
  $1, $2, $3, $4
)
`

type CreateRecipeTagParams struct {
	RecipeID  pgtype.UUID `json:"recipe_id"`
	TagID     pgtype.UUID `json:"tag_id"`
	CreatedBy pgtype.UUID `json:"created_by"`
	UpdatedBy pgtype.UUID `json:"updated_by"`
}

func (q *Queries) CreateRecipeTag(ctx context.Context, arg CreateRecipeTagParams) error {
	_, err := q.db.Exec(ctx, createRecipeTag,
		arg.RecipeID,
		arg.TagID,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	return err
}

const deleteRecipeIngredientsByRecipeID = `-- name: DeleteRecipeIngredientsByRecipeID :exec
DELETE FROM recipe_ingredients
WHERE recipe_id = $1
`

func (q *Queries) DeleteRecipeIngredientsByRecipeID(ctx context.Context, recipeID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteRecipeIngredientsByRecipeID, recipeID)
	return err
}

const deleteRecipeStepsByRecipeID = `-- name: DeleteRecipeStepsByRecipeID :exec
DELETE FROM recipe_steps
WHERE recipe_id = $1
`

func (q *Queries) DeleteRecipeStepsByRecipeID(ctx context.Context, recipeID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteRecipeStepsByRecipeID, recipeID)
	return err
}

const deleteRecipeTagsByRecipeID = `-- name: DeleteRecipeTagsByRecipeID :exec
DELETE FROM recipe_tags
WHERE recipe_id = $1
`

func (q *Queries) DeleteRecipeTagsByRecipeID(ctx context.Context, recipeID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteRecipeTagsByRecipeID, recipeID)
	return err
}

const getRecipeByID = `-- name: GetRecipeByID :one
SELECT id, title, servings, prep_time_minutes, total_time_minutes, source_url, notes, recipe_book_id, deleted_at, created_at, created_by, updated_at, updated_by
FROM recipes
WHERE id = $1
`

func (q *Queries) GetRecipeByID(ctx context.Context, id pgtype.UUID) (Recipe, error) {
	row := q.db.QueryRow(ctx, getRecipeByID, id)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Servings,
		&i.PrepTimeMinutes,
		&i.TotalTimeMinutes,
		&i.SourceUrl,
		&i.Notes,
		&i.RecipeBookID,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const getRecipeDeletedAtByID = `-- name: GetRecipeDeletedAtByID :one
SELECT deleted_at
FROM recipes
WHERE id = $1
`

func (q *Queries) GetRecipeDeletedAtByID(ctx context.Context, id pgtype.UUID) (pgtype.Timestamptz, error) {
	row := q.db.QueryRow(ctx, getRecipeDeletedAtByID, id)
	var deleted_at pgtype.Timestamptz
	err := row.Scan(&deleted_at)
	return deleted_at, err
}

const listRecipeIngredientsByRecipeID = `-- name: ListRecipeIngredientsByRecipeID :many
SELECT
  ri.id,
  ri.recipe_id,
  ri.position,
  ri.quantity,
  ri.quantity_text,
  ri.unit,
  ri.item_id,
  i.name AS item_name,
  i.store_url AS item_store_url,
  i.aisle_id AS item_aisle_id,
  a.name AS aisle_name,
  a.sort_group AS aisle_sort_group,
  a.sort_order AS aisle_sort_order,
  a.numeric_value AS aisle_numeric_value,
  ri.prep,
  ri.notes,
  ri.original_text,
  ri.created_at,
  ri.created_by,
  ri.updated_at,
  ri.updated_by
FROM recipe_ingredients ri
JOIN items i ON i.id = ri.item_id
LEFT JOIN grocery_aisles a ON a.id = i.aisle_id
WHERE ri.recipe_id = $1
ORDER BY ri.position ASC
`

type ListRecipeIngredientsByRecipeIDRow struct {
	ID                pgtype.UUID        `json:"id"`
	RecipeID          pgtype.UUID        `json:"recipe_id"`
	Position          int32              `json:"position"`
	Quantity          pgtype.Numeric     `json:"quantity"`
	QuantityText      pgtype.Text        `json:"quantity_text"`
	Unit              pgtype.Text        `json:"unit"`
	ItemID            pgtype.UUID        `json:"item_id"`
	ItemName          string             `json:"item_name"`
	ItemStoreUrl      pgtype.Text        `json:"item_store_url"`
	ItemAisleID       pgtype.UUID        `json:"item_aisle_id"`
	AisleName         pgtype.Text        `json:"aisle_name"`
	AisleSortGroup    pgtype.Int4        `json:"aisle_sort_group"`
	AisleSortOrder    pgtype.Int4        `json:"aisle_sort_order"`
	AisleNumericValue pgtype.Int4        `json:"aisle_numeric_value"`
	Prep              pgtype.Text        `json:"prep"`
	Notes             pgtype.Text        `json:"notes"`
	OriginalText      pgtype.Text        `json:"original_text"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	CreatedBy         pgtype.UUID        `json:"created_by"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	UpdatedBy         pgtype.UUID        `json:"updated_by"`
}

func (q *Queries) ListRecipeIngredientsByRecipeID(ctx context.Context, recipeID pgtype.UUID) ([]ListRecipeIngredientsByRecipeIDRow, error) {
	rows, err := q.db.Query(ctx, listRecipeIngredientsByRecipeID, recipeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRecipeIngredientsByRecipeIDRow{}
	for rows.Next() {
		var i ListRecipeIngredientsByRecipeIDRow
		if err := rows.Scan(
			&i.ID,
			&i.RecipeID,
			&i.Position,
			&i.Quantity,
			&i.QuantityText,
			&i.Unit,
			&i.ItemID,
			&i.ItemName,
			&i.ItemStoreUrl,
			&i.ItemAisleID,
			&i.AisleName,
			&i.AisleSortGroup,
			&i.AisleSortOrder,
			&i.AisleNumericValue,
			&i.Prep,
			&i.Notes,
			&i.OriginalText,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecipeStepsByRecipeID = `-- name: ListRecipeStepsByRecipeID :many
SELECT id, recipe_id, step_number, instruction, created_at, created_by, updated_at, updated_by
FROM recipe_steps
WHERE recipe_id = $1
ORDER BY step_number ASC
`

func (q *Queries) ListRecipeStepsByRecipeID(ctx context.Context, recipeID pgtype.UUID) ([]RecipeStep, error) {
	rows, err := q.db.Query(ctx, listRecipeStepsByRecipeID, recipeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RecipeStep{}
	for rows.Next() {
		var i RecipeStep
		if err := rows.Scan(
			&i.ID,
			&i.RecipeID,
			&i.StepNumber,
			&i.Instruction,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecipeTagsByRecipeID = `-- name: ListRecipeTagsByRecipeID :many
SELECT
  t.id,
  t.name
FROM recipe_tags rt
JOIN tags t ON t.id = rt.tag_id
WHERE rt.recipe_id = $1
ORDER BY t.name ASC
`

type ListRecipeTagsByRecipeIDRow struct {
	ID   pgtype.UUID `json:"id"`
	Name string      `json:"name"`
}

func (q *Queries) ListRecipeTagsByRecipeID(ctx context.Context, recipeID pgtype.UUID) ([]ListRecipeTagsByRecipeIDRow, error) {
	rows, err := q.db.Query(ctx, listRecipeTagsByRecipeID, recipeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRecipeTagsByRecipeIDRow{}
	for rows.Next() {
		var i ListRecipeTagsByRecipeIDRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecipeTagsByRecipeIDs = `-- name: ListRecipeTagsByRecipeIDs :many
SELECT
  rt.recipe_id,
  t.id,
  t.name
FROM recipe_tags rt
JOIN tags t ON t.id = rt.tag_id
WHERE rt.recipe_id = ANY($1::uuid[])
ORDER BY rt.recipe_id, t.name ASC
`

type ListRecipeTagsByRecipeIDsRow struct {
	RecipeID pgtype.UUID `json:"recipe_id"`
	ID       pgtype.UUID `json:"id"`
	Name     string      `json:"name"`
}

func (q *Queries) ListRecipeTagsByRecipeIDs(ctx context.Context, dollar_1 []pgtype.UUID) ([]ListRecipeTagsByRecipeIDsRow, error) {
	rows, err := q.db.Query(ctx, listRecipeTagsByRecipeIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRecipeTagsByRecipeIDsRow{}
	for rows.Next() {
		var i ListRecipeTagsByRecipeIDsRow
		if err := rows.Scan(&i.RecipeID, &i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecipes = `-- name: ListRecipes :many
SELECT
  r.id,
  r.title,
  r.servings,
  r.prep_time_minutes,
  r.total_time_minutes,
  r.source_url,
  r.notes,
  r.recipe_book_id,
  r.deleted_at,
  r.updated_at
FROM recipes r
WHERE
  ($1::text = '' OR r.title ILIKE ('%' || $1::text || '%'))
  AND ($2::uuid IS NULL OR r.recipe_book_id = $2::uuid)
  AND ($3::uuid IS NULL OR EXISTS (
    SELECT 1
    FROM recipe_tags rt
    WHERE rt.recipe_id = r.id AND rt.tag_id = $3::uuid
  ))
  AND ($4::boolean OR r.deleted_at IS NULL)
  AND (
    $5::timestamptz IS NULL
    OR (r.updated_at, r.id) < ($5::timestamptz, $6::uuid)
  )
ORDER BY r.updated_at DESC, r.id DESC
LIMIT $7
`

type ListRecipesParams struct {
	Q               string             `json:"q"`
	BookID          pgtype.UUID        `json:"book_id"`
	TagID           pgtype.UUID        `json:"tag_id"`
	IncludeDeleted  bool               `json:"include_deleted"`
	CursorUpdatedAt pgtype.Timestamptz `json:"cursor_updated_at"`
	CursorID        pgtype.UUID        `json:"cursor_id"`
	PageLimit       int32              `json:"page_limit"`
}

type ListRecipesRow struct {
	ID               pgtype.UUID        `json:"id"`
	Title            string             `json:"title"`
	Servings         int32              `json:"servings"`
	PrepTimeMinutes  int32              `json:"prep_time_minutes"`
	TotalTimeMinutes int32              `json:"total_time_minutes"`
	SourceUrl        pgtype.Text        `json:"source_url"`
	Notes            pgtype.Text        `json:"notes"`
	RecipeBookID     pgtype.UUID        `json:"recipe_book_id"`
	DeletedAt        pgtype.Timestamptz `json:"deleted_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListRecipes(ctx context.Context, arg ListRecipesParams) ([]ListRecipesRow, error) {
	rows, err := q.db.Query(ctx, listRecipes,
		arg.Q,
		arg.BookID,
		arg.TagID,
		arg.IncludeDeleted,
		arg.CursorUpdatedAt,
		arg.CursorID,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRecipesRow{}
	for rows.Next() {
		var i ListRecipesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Servings,
			&i.PrepTimeMinutes,
			&i.TotalTimeMinutes,
			&i.SourceUrl,
			&i.Notes,
			&i.RecipeBookID,
			&i.DeletedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreRecipeByID = `-- name: RestoreRecipeByID :execrows
UPDATE recipes
SET deleted_at = NULL,
    updated_at = now(),
    updated_by = $2
WHERE id = $1
`

type RestoreRecipeByIDParams struct {
	ID        pgtype.UUID `json:"id"`
	UpdatedBy pgtype.UUID `json:"updated_by"`
}

func (q *Queries) RestoreRecipeByID(ctx context.Context, arg RestoreRecipeByIDParams) (int64, error) {
	result, err := q.db.Exec(ctx, restoreRecipeByID, arg.ID, arg.UpdatedBy)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const softDeleteRecipeByID = `-- name: SoftDeleteRecipeByID :execrows
UPDATE recipes
SET deleted_at = now(),
    updated_at = now(),
    updated_by = $2
WHERE id = $1
`

type SoftDeleteRecipeByIDParams struct {
	ID        pgtype.UUID `json:"id"`
	UpdatedBy pgtype.UUID `json:"updated_by"`
}

func (q *Queries) SoftDeleteRecipeByID(ctx context.Context, arg SoftDeleteRecipeByIDParams) (int64, error) {
	result, err := q.db.Exec(ctx, softDeleteRecipeByID, arg.ID, arg.UpdatedBy)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateRecipeByID = `-- name: UpdateRecipeByID :one
UPDATE recipes
SET title = $2,
    servings = $3,
    prep_time_minutes = $4,
    total_time_minutes = $5,
    source_url = $6,
    notes = $7,
    recipe_book_id = $8,
    updated_at = now(),
    updated_by = $9
WHERE id = $1
RETURNING id, title, servings, prep_time_minutes, total_time_minutes, source_url, notes, recipe_book_id, deleted_at, created_at, created_by, updated_at, updated_by
`

type UpdateRecipeByIDParams struct {
	ID               pgtype.UUID `json:"id"`
	Title            string      `json:"title"`
	Servings         int32       `json:"servings"`
	PrepTimeMinutes  int32       `json:"prep_time_minutes"`
	TotalTimeMinutes int32       `json:"total_time_minutes"`
	SourceUrl        pgtype.Text `json:"source_url"`
	Notes            pgtype.Text `json:"notes"`
	RecipeBookID     pgtype.UUID `json:"recipe_book_id"`
	UpdatedBy        pgtype.UUID `json:"updated_by"`
}

func (q *Queries) UpdateRecipeByID(ctx context.Context, arg UpdateRecipeByIDParams) (Recipe, error) {
	row := q.db.QueryRow(ctx, updateRecipeByID,
		arg.ID,
		arg.Title,
		arg.Servings,
		arg.PrepTimeMinutes,
		arg.TotalTimeMinutes,
		arg.SourceUrl,
		arg.Notes,
		arg.RecipeBookID,
		arg.UpdatedBy,
	)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Servings,
		&i.PrepTimeMinutes,
		&i.TotalTimeMinutes,
		&i.SourceUrl,
		&i.Notes,
		&i.RecipeBookID,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}
