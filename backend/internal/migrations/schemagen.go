package migrations

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
)

const (
	gooseUpDirective   = "-- +goose Up"
	gooseDownDirective = "-- +goose Down"
)

// GenerateSQLCSchemaFromGooseMigrations renders a deterministic schema file suitable for sqlc
// by concatenating the "Up" sections of all Goose SQL migrations in migrationsDir.
//
// The output is intended to be written to `backend/internal/db/schema.sql` and checked in.
// That file must not be edited by hand; migrations are the single source of truth.
func GenerateSQLCSchemaFromGooseMigrations(migrationsDir string) ([]byte, error) {
	if strings.TrimSpace(migrationsDir) == "" {
		return nil, errors.New("migrations dir is required")
	}

	entries, err := os.ReadDir(migrationsDir)
	if err != nil {
		return nil, fmt.Errorf("read migrations dir: %w", err)
	}

	var buf bytes.Buffer
	fmt.Fprintln(&buf, "-- Code generated by cmd/schema-gen; DO NOT EDIT.")
	fmt.Fprintln(&buf, "-- Source: Goose migrations in backend/migrations/")
	fmt.Fprintln(&buf)

	wroteAnyMigration := false
	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		if filepath.Ext(entry.Name()) != ".sql" {
			continue
		}

		path := filepath.Join(migrationsDir, entry.Name())
		content, readErr := os.ReadFile(path) //nolint:gosec // path comes from ReadDir(migrationsDir) and is not user-controlled
		if readErr != nil {
			return nil, fmt.Errorf("read migration %s: %w", entry.Name(), readErr)
		}

		up, parseErr := extractGooseUpSQL(bytes.NewReader(content))
		if parseErr != nil {
			return nil, fmt.Errorf("parse migration %s: %w", entry.Name(), parseErr)
		}
		if len(up) == 0 {
			continue
		}

		if wroteAnyMigration {
			buf.WriteByte('\n')
		}
		buf.Write(up)
		buf.WriteByte('\n')
		wroteAnyMigration = true
	}

	if !wroteAnyMigration {
		return nil, errors.New("no .sql migrations found")
	}

	return buf.Bytes(), nil
}

func extractGooseUpSQL(r io.Reader) ([]byte, error) {
	scanner := bufio.NewScanner(r)

	inUp := false
	var lines []string
	for scanner.Scan() {
		line := scanner.Text()
		switch strings.TrimSpace(line) {
		case gooseUpDirective:
			inUp = true
			continue
		case gooseDownDirective:
			inUp = false
			continue
		}
		if !inUp {
			continue
		}
		lines = append(lines, line)
	}
	if err := scanner.Err(); err != nil {
		return nil, err
	}

	lines = trimEmptyLines(lines)
	if len(lines) == 0 {
		return nil, nil
	}

	var buf bytes.Buffer
	for i, line := range lines {
		if i > 0 {
			buf.WriteByte('\n')
		}
		buf.WriteString(line)
	}
	return buf.Bytes(), nil
}

func trimEmptyLines(lines []string) []string {
	start := 0
	for start < len(lines) && strings.TrimSpace(lines[start]) == "" {
		start++
	}

	end := len(lines)
	for end > start && strings.TrimSpace(lines[end-1]) == "" {
		end--
	}

	return lines[start:end]
}
